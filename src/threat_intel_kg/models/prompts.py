"""
Prompts for extracting knowledge graphs from security reports.
"""

from typing import List, Dict, Any

# Base Prompt Template
PROMPT_TEMPLATE = """
# Neo4j Knowledge Graph Instructions
## 1. Overview
You are an advanced algorithm specialized in extracting and structuring information to build a Neo4j graph from cyber security reports.
- **Nodes** represent cyber security entities and concepts relevant to the report.
- The goal is to create a clear and comprehensive Neo4j graph that accurately reflects the relationships and entities within the cyber security context.
## 2. Labeling Nodes
- **Consistency**: Use standardized labels for node types to maintain uniformity across the graph.
  - Examples of node labels include **"Threat"**, **"Vulnerability"**, **"Asset"**, **"Actor"**, **"Attack"**, **"Mitigation"**, and **"Indicator"**.
- **Node IDs**: Utilize descriptive and human-readable identifiers for node IDs based on the entities' names or unique attributes found in the text. Do not use integers or autogenerated IDs.
{allowed_nodes_str}
{allowed_rels_str}
## 3. Handling Numerical Data and Dates
- **Attributes**: Incorporate numerical data and dates as properties of the relevant nodes.
  - For example, attach the property `severityScore` to a **"Vulnerability"** node or `discoveryDate` to a **"Threat"** node.
- **No Separate Nodes**: Do not create separate nodes for numerical values or dates. Always attach them as properties of existing nodes.
- **Property Format**: Use key-value pairs for all properties.
- **Quotation Marks**: Avoid using escaped single or double quotes within property values.
- **Naming Convention**: Use camelCase for property keys, such as `impactLevel` or `firstSeen`.
## 4. Coreference Resolution
- **Entity Consistency**: Ensure that each entity is represented by a single, consistent identifier throughout the graph.
  - For instance, if "Advanced Persistent Threat 29" is referred to as "APT29" or "the group" in different parts of the report, always use "Advanced Persistent Threat 29" as the node ID.
- **Clarity**: Maintain clarity by using the most complete and descriptive identifier for each entity to avoid ambiguity.
## 5. Neo4j Compatibility
- **Format**: Structure the output in a JSON format compatible with Neo4j's import tools, including separate sections for nodes and relationships.
- **Identifiers**: Ensure that each node has a unique `id` and that relationships correctly reference these IDs in the `startNode` and `endNode` fields.
## 6. Output Format
Return the graph as JSON with the exact format of:
{{
  "nodes": [
    {{
      "id": "unique_id_string",
      "type": "NodeType",
      "properties": [
        {{"key": "propertyName", "value": "propertyValue"}}
      ]
    }}
  ],
  "rels": [
    {{
      "source": {{"id": "source_node_id", "type": "SourceNodeType"}},
      "target": {{"id": "target_node_id", "type": "TargetNodeType"}},
      "type": "RELATIONSHIP_TYPE",
      "properties": [
        {{"key": "propertyName", "value": "propertyValue"}}
      ]
    }}
  ]
}}
## 7. Strict Compliance
Adhere strictly to these guidelines. Any deviation may lead to errors in the graph structure or import process.
"""


def get_prompt_template(allowed_nodes: List[str], allowed_rels: List[str]) -> str:
    """
    Generate the prompt template with allowed nodes and relationships.

    Args:
        allowed_nodes: List of allowed node labels.
        allowed_rels: List of allowed relationship types.

    Returns:
        Formatted prompt template. This will contain the {input} placeholder
        to be filled later by the extractor.
    """
    allowed_nodes_str = "- **Allowed Node Labels:** " + ", ".join(allowed_nodes) if allowed_nodes else ""
    allowed_rels_str = "- **Allowed Relationship Types:** " + ", ".join(allowed_rels) if allowed_rels else ""
    # This format call only fills allowed_nodes_str and allowed_rels_str
    return PROMPT_TEMPLATE.format(allowed_nodes_str=allowed_nodes_str, allowed_rels_str=allowed_rels_str)


def create_prompt_template(prompt_text: str) -> str:
    """
    Format the prompt text with placeholders for input.

    Args:
        prompt_text: The text for the prompt template.

    Returns:
        A formatted string prompt template.
    """
    # This function seems redundant given how get_prompt_template works now.
    # It doesn't appear to be used by the OpenAI extractor.
    return prompt_text